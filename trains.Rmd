---
title: "Replication Report on Enos (2014)"
author: "David Kane"
date: '2019-02-15'
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(ri)
library(RItools)
library(xtable)
library(tidyverse)

# The raw data does not have a column name for the first column, so, by default
# it gets X1. But this looks to be just a row number, so let's ignore. 

# The variable names in dat_all and dat_all_prime are just pathetic, as if they
# are the result of an extremely sloppy merge. What is the difference, for
# example, between party.x and party.y? The names in dat_t1 are fine.

dat.all <- read_csv("pnas_data.csv")

dat.t1  <- read_csv("t1_data.csv") # Only uses for some missing data tests?

dat.all.prime <- read_csv("prime_data.csv")

# Ignore the face data for now.

```

## Table 2

```{r table_2, results="asis"}
# I believe that this is the code which drives Table 2. I deleted the other
# tests. Note that income is present in the published table but at a different
# location than in the code. I could not get replicate the income numbers.
# Error?

out.balance.test <- xBalance(fmla = treatment ~ liberal + republican + obama.disapprove + 
                               ride.everyday + voted.2010 + romney.voter + Hispanics.x + 
                               age + residency.new + hispanic.new + college + 
                               male + white + income.new , data = dat.all, 
                             report = c("std.diffs","z.scores","adj.means","chisquare.test"), 
                             strata = factor(dat.all$station))

# Need to print this out more nicely, including adding some information like n.
# The object is a weird list. Maybe learn some gt to make it pretty? Most
# numbers seem spot on.

kable(out.balance.test[1], digits = 2)

```

```{r table_1}
# Some comments would be nice!

repeats <- c("numberim","Remain","Englishlan")

x.names <- paste(repeats,".x",sep="")
y.names <- paste(repeats,".y",sep="")

covariates <- c('line.x')

###treated first
final.mat <- matrix(nrow = 0, ncol = 8)

subsets <- c('all','no.car')

# This code is absurd. Not the least is using "subset" --- the name of a base
# function! --- as a character vector.


for(subset in subsets){

	out.mat = matrix(nrow = length(repeats), ncol = 8)
	
	if(subset == 'all'){
		dat.subset = dat.all
		}
	if(subset ==  'no.car'){
		dat.subset = dat.all[dat.all$habits != 1,]
		}

		
	z.variable = 'treatment'
	
	# This portion is really tricky because x.new and friends gets created as a
	# data.frame, which is now just an element of the dat.subset list. That is
	# weird enough, but then, later, we try to work with it and bad stuff happens.
	# I suspect that all this is fine if we just never turned the initial data into
	# a tibble. But maybe not! And, even if it does work, it is a bad idea. Trick
	# was to add "drop = TRUE", which ensures that the resulting object is a
	# vector.
	
	for(j in 1:length(repeats)){
		dat.subset$x.new <- (dat.subset[, x.names[j], drop = TRUE]- 1)/4  ##rescale x to 0-1
		dat.subset$y.new <- (dat.subset[, y.names[j], drop = TRUE]- 1)/4  ##rescale y to 0-1
		dat.subset$Y     <-  dat.subset$y.new - dat.subset$x.new
		
		dat.use <- dat.subset[is.na(dat.subset$Y) == F,]
		
		x.sd = sd(as.vector(dat.use$x.new),na.rm = T)
		x.mean = mean(dat.use$x.new,na.rm = T)
		y.mean = mean(dat.use$y.new,na.rm = T)
		y.treat = mean(dat.use$y.new[dat.use$treatment==1],na.rm = T)
	
		station.treatment.table <- table(dat.use$station, dat.use[ ,z.variable, drop = TRUE])
		no.control.stations = names(which(station.treatment.table[,1] == 0))
		no.treatment.stations = names(which(station.treatment.table[,2] == 0))
		dat.use = dat.use[!dat.use$station%in%c(no.control.stations,no.treatment.stations),]
				
		
		dat.use$station = factor(dat.use$station)
		dat.use$treated_unit = factor(dat.use$treated_unit)
		Xs = data.matrix(dat.use[,covariates])
		
		perms <- genperms(Z = dat.use[,z.variable], blockvar=dat.use$station, clustvar=dat.use$treated_unit)
		probs = genprobexact(Z = dat.use[,z.variable], blockvar=dat.use$station, clustvar=dat.use$treated_unit)

		ate = estate(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], X = Xs, prob = probs)
		Ys = genouts(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], ate = 0)
		distout <- gendist(Ys,perms, prob=probs)
		disp =	dispdist(distout, ate = ate, display.plot = F)
		
		out.mat[j,1] = repeats[j]
		out.mat[j,2] = subset
		out.mat[j,3] = nrow(dat.use)
		out.mat[j,4] = ate
		out.mat[j,5] = disp$greater.p.value
		out.mat[j,6] = disp$lesser.p.value
		out.mat[j,7] = x.sd
		out.mat[j,8] = x.mean
		}
	final.mat = rbind(final.mat,out.mat)
	}

final.mat = as.data.frame(final.mat)
colnames(final.mat) = c('variable','subset','N','ate','greater.p.value','lesser.p.value','x.sd','x.mean')
print(final.mat)

final.mat.main = final.mat ##final.mat for output creation later

```

