---
title: "Replication Report on Enos (2014)"
author: "David Kane"
date: '2019-02-15'
output:
  pdf_document: default
citation_package: natbib
bibliography: bibliography.bib
---

## Abstract

I replicate "Causal effect of intergroup contact on exclusionary attitudes" (@enos2014) using code/data deposited in the Harvard Dataverse (@DVN/DOP4UB_2017). There are two figures and three tables in the original article.  


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(ri)
library(RItools)
library(xtable)
library(car)
library(gt)
library(tidyverse)

# The raw data does not have a column name for the first column, so, by default
# it gets X1. But this looks to be just a row number, so let's ignore. 

# The variable names in dat_all and dat_all_prime are just pathetic, as if they
# are the result of an extremely sloppy merge. What is the difference, for
# example, between party.x and party.y? The names in dat_t1 are fine.

# Using read_csv() causes lots of problems later one because dat.all, for
# example, as a tibble behaves differently than dat.all as a data frame. The key
# issue is that when you select out a single column, a data frame will
# automatically drop dimensions and become a vector. A tibble requires you to
# specify drop = TRUE.

dat.all <- read_csv("data/pnas_data.csv")

dat.t1  <- read_csv("data/t1_data.csv") # Only uses for some missing data tests?

dat.all.prime <- read_csv("data/prime_data.csv")

# Other data sets only seem relevant for supplementary material.

```

## Table 2

```{r table_2, results="asis"}
# I believe that this is the code which drives Table 2. I deleted the other
# tests. Note that income is present in the published table but at a different
# location than in the code. I could not get replicate the income numbers.
# Error?

out.balance.test <- xBalance(fmla = treatment ~ liberal + republican + obama.disapprove + 
                               ride.everyday + voted.2010 + romney.voter + Hispanics.x + 
                               age + residency.new + hispanic.new + college + 
                               male + white + income.new , data = dat.all, 
                             report = c("std.diffs","z.scores","adj.means"), 
                             strata = factor(dat.all$station))

# This creates an object of class xbal, which is obviously too annoying to work
# with since it is also a list with two items, and the first item is very
# strange. However, this incantation gets out the matrix of numbers we care
# about.

x <- out.balance.test[1]$results[,,1][, 1:4]

# Enos just uses xtable(), for which xbal provides a method. But it sure does
# look ugly because xtable() has so few options. So, I am trying kable() ---
# which is, perhaps, designed to work well with objects that provide xtable
# methods?

# We have our matrix, but now we need to add row names to it because
# this is where kable looks for that information.

row.names(x) <- c("Liberal", "Republican", "Obama disapprove", "Ride MBTA every day",
                  "Voted 2010", "Romney voter", "Hispanic threat", "Age", "Residency year",
                  "College", "Male", " Hispanic", "White", "Income")

kable(x, digits = 2, 
      caption = "Covariate balance across treatment conditions",
      col.names = c("Control", "Treatment", "Standard difference", "Z Score"))

# Note that I keep getting weird warnings about "Unknown or uninitialised
# column: 'non.white'." and for residency.new. But who is trying to use
# non.white? And residency.new, which is being used in xBalance, seems fine.
# Weird . . .

```



```{r table_1}
# Some comments would be nice!

repeats <- c("numberim","Remain","Englishlan")

x.names <- paste(repeats,".x",sep="")
y.names <- paste(repeats,".y",sep="")

covariates <- c('line.x')

###treated first
final.mat <- matrix(nrow = 0, ncol = 8)

subsets <- c('all','no.car')

# This code is absurd. Not the least is using "subset" --- the name of a base
# function! --- as a character vector.


for(subset in subsets){

	out.mat = matrix(nrow = length(repeats), ncol = 8)
	
	if(subset == 'all'){
		dat.subset = dat.all
		}
	if(subset ==  'no.car'){
		dat.subset = dat.all[dat.all$habits != 1,]
		}

		
	z.variable = 'treatment'
	
	# This portion is really tricky because x.new and friends gets created as a
	# data.frame, which is now just an element of the dat.subset list. That is
	# weird enough, but then, later, we try to work with it and bad stuff happens.
	# I suspect that all this is fine if we just never turned the initial data into
	# a tibble. But maybe not! And, even if it does work, it is a bad idea. Trick
	# was to add "drop = TRUE", which ensures that the resulting object is a
	# vector.
	
	for(j in 1:length(repeats)){
		dat.subset$x.new <- (dat.subset[, x.names[j], drop = TRUE]- 1)/4  ##rescale x to 0-1
		dat.subset$y.new <- (dat.subset[, y.names[j], drop = TRUE]- 1)/4  ##rescale y to 0-1
		dat.subset$Y     <-  dat.subset$y.new - dat.subset$x.new
		
		dat.use <- dat.subset[is.na(dat.subset$Y) == F,]
		
		x.sd = sd(as.vector(dat.use$x.new),na.rm = T)
		x.mean = mean(dat.use$x.new,na.rm = T)
		y.mean = mean(dat.use$y.new,na.rm = T)
		y.treat = mean(dat.use$y.new[dat.use$treatment==1],na.rm = T)
	
		station.treatment.table <- table(dat.use$station, dat.use[ ,z.variable, drop = TRUE])
		no.control.stations = names(which(station.treatment.table[,1] == 0))
		no.treatment.stations = names(which(station.treatment.table[,2] == 0))
		dat.use = dat.use[!dat.use$station%in%c(no.control.stations,no.treatment.stations),]
				
		
		dat.use$station = factor(dat.use$station)
		dat.use$treated_unit = factor(dat.use$treated_unit)
		Xs = data.matrix(dat.use[,covariates])
		
		perms <- genperms(Z = dat.use[,z.variable], blockvar=dat.use$station, clustvar=dat.use$treated_unit)
		probs = genprobexact(Z = dat.use[,z.variable], blockvar=dat.use$station, clustvar=dat.use$treated_unit)

		ate = estate(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], X = Xs, prob = probs)
		Ys = genouts(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], ate = 0)
		distout <- gendist(Ys,perms, prob=probs)
		disp =	dispdist(distout, ate = ate, display.plot = F)
		
		out.mat[j,1] = repeats[j]
		out.mat[j,2] = subset
		out.mat[j,3] = nrow(dat.use)
		out.mat[j,4] = ate
		out.mat[j,5] = disp$greater.p.value
		out.mat[j,6] = disp$lesser.p.value
		out.mat[j,7] = x.sd
		out.mat[j,8] = x.mean
		}
	final.mat = rbind(final.mat,out.mat)
	}

final.mat = as.data.frame(final.mat)
colnames(final.mat) = c('variable','subset','N','ate','greater.p.value','lesser.p.value','x.sd','x.mean')


final.mat.main = final.mat ##final.mat for output creation later

# Need more stuff before we can output the final table. Let's come back to this
# later. I am skipping subset_inference.r since it only (?) produces results for
# the supporting material.

```




```{r primetest, message=FALSE, warning=FALSE}
# This code looks a lot like the code above. Maybe combine them? Can't figure
# out how to get the messages about maximum iterations to stop printing.

# use randomization inference to look for changes in responses induced by
# experiment in subsets by covariates.


# recodes

# race variable

dat.all.prime$non.white = ifelse(dat.all.prime$race_4 == 1, 1,0)
dat.all.prime$non.white[is.na(dat.all.prime$non.white)==T] = 0

# Is there a data problem here? I don't think that residency.new is a variable
# in dat.all.prime. So, this first assignment fails, perhaps just because
# dat.all.prime is now a tibble. My fix: Just change the first assignment to
# ifelse to ensure clean creation.

dat.all.prime$residency.new <- ifelse(dat.all.prime$residency == 1, 1, NA)
dat.all.prime$residency.new[dat.all.prime$residency == 2] = 3.5
dat.all.prime$residency.new[dat.all.prime$residency == 3] = 7.5
dat.all.prime$residency.new[dat.all.prime$residency == 4] = 12.5
dat.all.prime$residency.new[dat.all.prime$residency == 5] = mean(dat.all.prime$age, na.rm = T)-15
dat.all.prime$residency.new[dat.all.prime$residency == 6] = mean(dat.all.prime$age, na.rm = T)

# recodes
# English language is reverse coded from other variables:

# Current warning: "Unreplaced values treated as NA as .x is not compatible.
# Please specify replacements exhaustively or supply .default" I wonder if we
# are using the same recode()? Note that he never loads dplyr. Ahh! He is using
# recode from the car package.

dat.all.prime$Englishlan.x =  car::recode(dat.all.prime$Englishlan.x, "5=1; 4=2; 3=3; 2=4; 1=5")
dat.all.prime$Englishlan.y = car::recode(dat.all.prime$Englishlan.y, "5=1; 4=2; 2=4; 1=5")


# gender recode

dat.all.prime$male = ifelse(dat.all.prime$gender == 1, 1, 0)

# inference

repeats = c("numberim","Remain","Englishlan")

x.names = paste(repeats,".x",sep="")
y.names = paste(repeats,".y",sep="")

covariates = c('line')

final.mat = matrix(nrow = 0, ncol = 8)

subsets = c('all.prime')

# If there is only one value for subsets, then why the loop???

for(subset in subsets){ ##b.only, complier, and non-compler subsets
	out.mat = matrix(nrow = length(repeats), ncol = 8)
	
	dat.subset = dat.all.prime
		
	z.variable = 'treatment'
	
	for(j in 1:length(repeats)){
	  dat.subset$x.new <- (dat.subset[, x.names[j], drop = TRUE]- 1)/4  ##rescale x to 0-1
		dat.subset$y.new <- (dat.subset[, y.names[j], drop = TRUE]- 1)/4  ##rescale y to 0-1
		dat.subset$Y = dat.subset$y.new - dat.subset$x.new
			
		dat.use = dat.subset[is.na(dat.subset$Y) == F,]
			
		x.sd = sd(dat.use$x.new,na.rm = T)
		x.mean = mean(dat.use$x.new,na.rm = T)
		
		Xs = data.matrix(dat.use[,covariates])
		
		# genperms() cat's annoying messages. Is there a simple way to stop this
		# nonsense?
		
		perms <-genperms(Z = dat.use[, z.variable, drop = TRUE])

		probs = genprobexact(Z = dat.use[, z.variable, drop = TRUE])
		ate = estate(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], X = Xs, prob = probs)
	
		Ys = genouts(Y = dat.use$Y, Z = dat.use[,z.variable], ate = 0)
		distout <- gendist(Ys,perms, prob=probs)
		disp =	dispdist(distout, ate = ate, display.plot = F)
		
		##fill matrix
		out.mat[j,1] = repeats[j]
		out.mat[j,2] = subset
		out.mat[j,3] = nrow(dat.use)
		out.mat[j,4] = ate
		out.mat[j,5] = disp$greater.p.value
		out.mat[j,6] = disp$lesser.p.value
		out.mat[j,7] = x.sd
		out.mat[j,8] = x.mean
		}
		final.mat = rbind(final.mat,out.mat)
}

	final.mat = as.data.frame(final.mat)
	colnames(final.mat) = c('variable','subset','N','ate','greater.p.value',
	                        'lesser.p.value','x.sd','x.mean')


	final.mat.prime = final.mat ##mat for creating output later



```



```{r output_create, results="asis"}
# Now that we have final.mat.main and final.mat.prime, we can make some nice
# output.
	

output.vars = c('numberim','Remain','Englishlan')
 
var.names = c('Number of immigrants be increased?',
              'Children of undocumented be allowed to stay?',
              'English as official language?')

 
 ##main results
 ##cumalative results output
 
final.mat.use = rbind(final.mat.main,final.mat.prime)

 final.mat.use$greater.p.value = as.numeric(as.character(final.mat.use$greater.p.value)); final.mat.use$lesser.p.value = as.numeric(as.character(final.mat.use$lesser.p.value)); final.mat.use$ate = as.numeric(as.character(final.mat.use$ate)); final.mat.use$x.mean = as.numeric(as.character(final.mat.use$x.mean)); final.mat.use$x.sd = as.numeric(as.character(final.mat.use$x.sd)); final.mat.use$N = as.numeric(as.character(final.mat.use$N))
 
 final.mat.use$p.value = final.mat.use$greater.p.value

 final.mat.redact = final.mat.use[,c('variable','subset','ate','p.value','x.mean','x.sd','N')]
 final.mat.redact[,c('ate','p.value','x.mean','x.sd')] = round(final.mat.redact[,c('ate','p.value','x.mean','x.sd')],3)

 final.mat.redact$ate.new = paste(final.mat.redact$ate,' (',final.mat.redact$p.value,')',sep='')
 final.mat.redact$x.mean.new = paste(final.mat.redact$x.mean,' (',final.mat.redact$x.sd,')',sep='')

 out.mat.a = final.mat.redact[final.mat.redact$subset == 'all'&final.mat.redact$variable %in% output.vars,]

 out.mat.a = final.mat.redact[final.mat.redact$subset == 'all'&final.mat.redact$variable %in% output.vars,c('ate.new')]	
 out.mat.c = final.mat.redact[final.mat.redact$subset == 'no.car'&final.mat.redact$variable %in% output.vars,c('ate.new')]
 out.mat.x = final.mat.redact[final.mat.redact$subset == 'all'&final.mat.redact$variable %in% output.vars,c('x.mean.new')]
 Ns = c('N',max(final.mat.redact$N[final.mat.redact$subset=='all']),
	max(final.mat.redact$N[final.mat.redact$subset=='no.car']),
	max(final.mat.redact$N[final.mat.redact$subset=='all'])
	)

 h1 = c('',paste('(',1:3,')',sep = ''))
 h2 = c('','all respondents','waits on platform','all respondents')
 h3 = c('question','ATE (p)','CATE (p)','T1 levels (sd)')
 hs = rbind(h1,h2,h3)
 row.names(hs) = NULL
	
 out.mat = cbind(out.mat.a,cbind(out.mat.c,out.mat.x))
 out.mat = cbind(var.names,out.mat)
 out.mat = rbind(out.mat,Ns)
 
 out.mat = rbind(hs,out.mat)
 
 kable(out.mat, digits = 3)
 


 ##prime results
 
 out.mat.p = final.mat.redact[final.mat.redact$subset == 'all.prime' & 
                                final.mat.redact$variable %in% output.vars, c('ate.new')]
 
 Ns = c('N',max(final.mat.redact$N[final.mat.redact$subset=='all.prime']),
	max(final.mat.redact$N[final.mat.redact$subset=='all']))

 h1 = c('',paste('(',1:2,')',sep = ''))
 h2 = c('','prime experiment','all respondents')
 h3 = c('question','ATE (p)','ATE (p)')	
 hs = rbind(h1,h2,h3)
 row.names(hs) = NULL
	
 out.mat = cbind(out.mat.p,out.mat.a)
 out.mat = cbind(var.names,out.mat)
 out.mat = rbind(out.mat,Ns)
 out.mat = rbind(hs,out.mat)
 
 kable(out.mat, digits = 3)
 
```


## References
