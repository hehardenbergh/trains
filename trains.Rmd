---
title: "Replication Report on Enos (2014)"
author: "David Kane"
date: '2019-02-15'
output:
  html_document: default
citation_package: natbib
bibliography: bibliography.bib
---

Add n row to Table 2.


## Abstract

I replicate "Causal effect of intergroup contact on exclusionary attitudes" (@enos2014) using code/data deposited in the Harvard Dataverse (@DVN/DOP4UB_2017). There are two figures and three tables in the original article. Tables 1 and 2 can be, almost, perfectly replicated. Table 3 and the two figures can not be replicated from the code/data on deposit at the Dataverse.  


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(ri)
library(RItools)
library(xtable)
library(gt)
library(tidyverse)

# The raw data does not have a column name for the first column, so, by default
# it gets X1. But this looks to be just a row number, so let's ignore. 

# The variable names in dat_all and dat_all_prime are just pathetic, as if they
# are the result of an extremely sloppy merge. What is the difference, for
# example, between party.x and party.y? The names in dat_t1 are fine.

# Using read_csv() causes lots of problems later one because dat.all, for
# example, as a tibble behaves differently than dat.all as a data frame. The key
# issue is that when you select out a single column, a data frame will
# automatically drop dimensions and become a vector. A tibble requires you to
# specify drop = TRUE.

dat.all <- read_csv("data/pnas_data.csv")

dat.t1  <- read_csv("data/t1_data.csv") # Only uses for some missing data tests?

dat.all.prime <- read_csv("data/prime_data.csv")

# Other data sets only seem relevant for supplementary material . . .

```

## Table 1. Experiment results

I am able to replicate all the numbers from Table 1. For convenience, I have placed the mean estimates and the p-values in separate tables below. One clarification is that the values for *n* are somewhat misleading. *n* varies across the questions. For example, *n* for the question about "English as official language?" is 109, as stated. But the *n* for "Number of immigrants be increased" is only 106. It is, obviously, sloppy to list a single *n* when, in fact, *n* varies across questions. The same issue arises with regard to the subset of commuters who wait in the platform. The *n* for "Number of immigrants be increased" is only 98, as compared to the stated 100 for the other two questions. This is a minor point with no meaningful implication for the results.

```{r table_1}
# Some comments would be nice!

repeats <- c("numberim","Remain","Englishlan")

x.names <- paste(repeats,".x",sep="")
y.names <- paste(repeats,".y",sep="")

covariates <- c('line.x')

###treated first
final.mat <- matrix(nrow = 0, ncol = 8)

subsets <- c('all','no.car')

# This code is absurd. Not the least is using "subset" --- the name of a base
# function! --- as a character vector. Worth the hour (or more!) it would take
# to refactor?


for(subset in subsets){

	out.mat = matrix(nrow = length(repeats), ncol = 8)
	
	if(subset == 'all'){
		dat.subset = dat.all
		}
	if(subset ==  'no.car'){
		dat.subset = dat.all[dat.all$habits != 1,]
		}

		
	z.variable = 'treatment'
	
	# This portion is really tricky because x.new and friends gets created as a
	# data.frame, which is now just an element of the dat.subset list. That is
	# weird enough, but then, later, we try to work with it and bad stuff happens.
	# I suspect that all this is fine if we just never turned the initial data into
	# a tibble. But maybe not! And, even if it does work, it is a bad idea. Trick
	# was to add "drop = TRUE", which ensures that the resulting object is a
	# vector.
	
	for(j in 1:length(repeats)){
		dat.subset$x.new <- (dat.subset[, x.names[j], drop = TRUE]- 1)/4  ##rescale x to 0-1
		dat.subset$y.new <- (dat.subset[, y.names[j], drop = TRUE]- 1)/4  ##rescale y to 0-1
		dat.subset$Y     <-  dat.subset$y.new - dat.subset$x.new
		
		dat.use <- dat.subset[is.na(dat.subset$Y) == F,]
		
		x.sd = sd(as.vector(dat.use$x.new),na.rm = T)
		x.mean = mean(dat.use$x.new,na.rm = T)
		y.mean = mean(dat.use$y.new,na.rm = T)
		y.treat = mean(dat.use$y.new[dat.use$treatment==1],na.rm = T)
	
		station.treatment.table <- table(dat.use$station, dat.use[ ,z.variable, drop = TRUE])
		no.control.stations = names(which(station.treatment.table[,1] == 0))
		no.treatment.stations = names(which(station.treatment.table[,2] == 0))
		dat.use = dat.use[!dat.use$station%in%c(no.control.stations,no.treatment.stations),]
				
		
		dat.use$station = factor(dat.use$station)
		dat.use$treated_unit = factor(dat.use$treated_unit)
		Xs = data.matrix(dat.use[,covariates])
		
		perms <- genperms(Z = dat.use[,z.variable], blockvar=dat.use$station, clustvar=dat.use$treated_unit)
		probs = genprobexact(Z = dat.use[,z.variable], blockvar=dat.use$station, clustvar=dat.use$treated_unit)

		ate = estate(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], X = Xs, prob = probs)
		Ys = genouts(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], ate = 0)
		distout <- gendist(Ys,perms, prob=probs)
		disp =	dispdist(distout, ate = ate, display.plot = F)
		
		out.mat[j,1] = repeats[j]
		out.mat[j,2] = subset
		out.mat[j,3] = nrow(dat.use)
		out.mat[j,4] = ate
		out.mat[j,5] = disp$greater.p.value
		out.mat[j,6] = disp$lesser.p.value
		out.mat[j,7] = x.sd
		out.mat[j,8] = x.mean
		}
	final.mat = rbind(final.mat,out.mat)
	}

final.mat = as.data.frame(final.mat)
colnames(final.mat) = c('variable','subset','N','ate','greater.p.value','lesser.p.value','x.sd','x.mean')


final.mat.main = final.mat ##final.mat for output creation later

# Need more stuff before we can output the final table. Let's come back to this
# later. I am skipping subset_inference.r since it only (?) produces results for
# the supporting material.

```



```{r output_create, results="asis"}
# OMG! He calculates many (most?) of these numbers as factors! Check out
# sapply(final.mat.main, class). (Or is that somehow my fault for using tibbles
# instead of data frames?) Then he has to convert to character and then to
# numeric to use them properly. Insanity! 

# But, also, there should be a better way to clean this up.

final.mat.main$ate    <- as.numeric(as.character(final.mat.main$ate)) 
final.mat.main$N      <- as.numeric(as.character(final.mat.main$N)) 
final.mat.main$x.mean <- as.numeric(as.character(final.mat.main$x.mean)) 
final.mat.main$x.sd   <- as.numeric(as.character(final.mat.main$x.sd)) 
final.mat.main$greater.p.value <- as.numeric(as.character(final.mat.main$greater.p.value)) 

# Now that we have final.mat.main, we can make some nice output. The annoying
# part is that this data is very poorly organized, if our main purpose is to
# create Table 1. I really ought to go back and recalculate these data frames in
# a tidyier fashion. But, for now, we will just pick out the parts we want.

# This was annoyingly hard, which goes to show why it is nice to calculate
# important numbers in a sensible way in the first place. Main trick is to
# create something of a convenient size, fill in the numbers and then start
# tabling. Must be easier ways to do this.

as_tibble(x = matrix(data = NA_real_, 
                     nrow = 4, 
                     ncol = 6,
                     dimnames = list(NULL, paste0("V", 1:6)))) %>%  
  
  # Remember: tibbles can't have row names anymore. So, we need to make them a
  # variable.
  
  mutate(question = c('Number of immigrants be increased?',
                      'Children of undocumented be allowed to stay?',
                      'English as official language?', 
                      'n')) %>% 
  mutate(V1 = c(final.mat.main$ate[1:3], final.mat.main$N[2]),
         V2 = c(final.mat.main$ate[4:6], final.mat.main$N[5]),
         V3 = c(final.mat.main$x.mean[1:3], final.mat.main$N[2]),
         V4 = c(final.mat.main$greater.p.value[1:3], NA),
         V5 = c(final.mat.main$greater.p.value[4:6], NA),
         V6 = c(final.mat.main$x.sd[1:3], NA)) %>% 

  #  Start charting!

  gt() %>% 
  tab_header(title = "Table 1. Experiment results") %>% 
  
  cols_move_to_start(columns = vars(question)) %>% 
  
  fmt_number(columns = starts_with("V"), decimals = 3, drop_trailing_zeros = TRUE) %>%
  
  # Combine the columns.
  
  cols_merge(col_1 = vars(V1), col_2 = vars(V4), pattern = "{1} ({2})") %>% 
  cols_merge(col_1 = vars(V2), col_2 = vars(V5), pattern = "{1} ({2})") %>% 
  cols_merge(col_1 = vars(V3), col_2 = vars(V6), pattern = "{1} ({2})") %>% 
  
  cols_label(question =  "Question",        
             V1 = "ATE (P)",
             V2 = "CATE (P)",
             V3 = "T1 levels (SD)") %>% 
  
  tab_source_note(source_note = 'In the first "All respondents" column, ATE represents responses in T2-T1 for the treatment group compared with the control group for the entire experimental sample. Positive values mean a more politically conservative response. In the "Waits on platform" column, CATEs are the Conditional Average Treatment Effects for persons who said they stand on the platform, rather than wait in their cars. In the second "All respondents" column, T1 levls and SDs for each variable for all respondents. All variables are scaled 0--1.') %>% 
  
  tab_options(footnote.glyph = c("*", "&dagger;")) %>%   
  
  tab_footnote(
    footnote = "P values from a one-tailed test against the Null Hypothesis of no effect are in parantheses.",
    locations = cells_column_labels(
      columns = vars(V1))) %>% 
  
  tab_footnote(
    footnote = "Each of the questions allowed responses on a five-point scale ranging from strongly agree to stringly disagree (exact answers were changed to be appropriate to the actual question.",
    locations = cells_data(
      columns = vars(question),
      rows = 1)) %>% 

  
  as_raw_html() %>% as.character() %>% cat()

# Discuss the confusion about exactly what those numbers mean. Does a high
# number mean the conservative answer?


```

\newpage

## Table 2

I am able to replicate all the values for Table 2, except for those related to income. But, even there, my results are very close to those published.

```{r table_2, results="asis", tab.cap = NULL}
# I believe that this is the code which drives Table 2. I deleted the other
# tests. Note that income is present in the published table but at a different
# location than in the code. I could not get replicate the income numbers.
# Error?

out.balance.test <- xBalance(fmla = treatment ~ liberal + republican + obama.disapprove + 
                               ride.everyday + voted.2010 + romney.voter + Hispanics.x + 
                               age + residency.new + college + male +
                               hispanic.new +  white + income.new, data = dat.all, 
                             report = c("std.diffs","z.scores","adj.means"), 
                             strata = factor(dat.all$station))

# This creates an object of class xbal, which is obviously too annoying to work
# with since it is also a list with two items, and the first item is very
# strange. However, the below incantation gets out the matrix of numbers we care
# about. Is there a better way?

# Once I have the data, I add a labelling var before getting to gt.

x <- as_tibble(out.balance.test[1]$results[,,1][, 1:4]) %>% 
  mutate(condition = c("Liberal", "Republican", "Obama disapprove", 
                  "Ride MBTA every day", "Voted 2010", "Romney voter", "Hispanic threat", 
                   "Age", "Residency year", "College", "Male",  
                   "Hispanic", "White", "Income"))


# Enos just uses xtable(), for which xbal provides a method. But it sure does
# look ugly because xtable() has so few options. I will use gt.

# https://gt.rstudio.com/articles/creating-display-tables.html

# I should do everything with gt going forward. It is obviously the future of
# table making in R. Are they working on regression displays? Still not sure how
# to use gt_preview() interactively.

gt_tbl <- x %>% 
  gt() %>% 
  tab_header(title = "Table 2. Covariate balance across treatment conditions") %>% 
  
  cols_move_to_start(columns = vars(condition)) %>% 
  
  # Set column names. Note that you need to use the original variable names in
  # functions like tab_footnote() even though we call those functions after
  # setting the column names. In other words, these are just for display, they
  # don't effect the data we are passing through the pipe.
  
  cols_label(condition =  "Condition",        
             `treatment=0` = "Control",
             `treatment=1` = "Treatment",
             std.diff = "Standard difference",       
             z = "Z Score") %>% 
  
  # Get the formatting correct.
  
  fmt_number(columns = vars(`treatment=0`, `treatment=1`, std.diff, z),
             decimals = 2) %>% 
  fmt_number(columns = vars(`treatment=0`, `treatment=1`),
             decimals = 0,
             rows = 14) %>% 
  
  # Take care of the footnotes. 
  
  tab_options(footnote.glyph = c("*", "&dagger;")) %>%   
  
  tab_footnote(
    footnote = "Difference in standardized units.",
    locations = cells_column_labels(
      columns = vars(std.diff))) %>% 
  
  tab_footnote(
    footnote = "Mean response values for the pretreatment variables accounting for stratification into train stations. All variables are 0 and 1 variables, except for Hispanic threat, which is a seven-point scale indicating how threatening respondents find Hispanics, recoded 0--1; residency, which is measured in years; and income, which is annual income in dollars.",
    locations = cells_data(
      columns = vars(condition),
      rows = 1)) 

gt_tbl %>% as_raw_html() %>% as.character() %>% cat()


```




## References
