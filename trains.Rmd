---
title: "Replication Report on Enos (2014)"
author: "David Kane"
date: '2019-02-15'
output:
  html_document: default
citation_package: natbib
bibliography: bibliography.bib
---

Get rid of recode and associated car package.
Start using gt.
Make a single table 1.


## Abstract

I replicate "Causal effect of intergroup contact on exclusionary attitudes" (@enos2014) using code/data deposited in the Harvard Dataverse (@DVN/DOP4UB_2017). There are two figures and three tables in the original article. Tables 1 and 2 can be, almost, perfectly replicated. Table 3 and the two figures can not be replicated from the code/data on deposit at the Dataverse.  


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(knitr)
library(ri)
library(RItools)
library(xtable)
library(car)
library(gt)
library(tidyverse)

# The raw data does not have a column name for the first column, so, by default
# it gets X1. But this looks to be just a row number, so let's ignore. 

# The variable names in dat_all and dat_all_prime are just pathetic, as if they
# are the result of an extremely sloppy merge. What is the difference, for
# example, between party.x and party.y? The names in dat_t1 are fine.

# Using read_csv() causes lots of problems later one because dat.all, for
# example, as a tibble behaves differently than dat.all as a data frame. The key
# issue is that when you select out a single column, a data frame will
# automatically drop dimensions and become a vector. A tibble requires you to
# specify drop = TRUE.

dat.all <- read_csv("data/pnas_data.csv")

dat.t1  <- read_csv("data/t1_data.csv") # Only uses for some missing data tests?

dat.all.prime <- read_csv("data/prime_data.csv")

# Other data sets only seem relevant for supplementary material . . .

```

## Table 1. Experiment results

I am able to replicate all the numbers from Table 1. For convenience, I have placed the mean estimates and the p-values in separate tables below. One clarification is that the values for *n* are somewhat misleading. *n* varies across the questions. For example, *n* for the question about "English as official language?" is 109, as stated. But the *n* for "Number of immigrants be increased" is only 106. It is, obviously, sloppy to list a single *n* when, in fact, *n* varies across questions. The same issue arises with regard to the subset of commuters who wait in the platform. The *n* for "Number of immigrants be increased" is only 98, as compared to the stated 100 for the other two questions. This is a minor point with no meaningful implication for the results.

```{r table_1}
# Some comments would be nice!

repeats <- c("numberim","Remain","Englishlan")

x.names <- paste(repeats,".x",sep="")
y.names <- paste(repeats,".y",sep="")

covariates <- c('line.x')

###treated first
final.mat <- matrix(nrow = 0, ncol = 8)

subsets <- c('all','no.car')

# This code is absurd. Not the least is using "subset" --- the name of a base
# function! --- as a character vector.


for(subset in subsets){

	out.mat = matrix(nrow = length(repeats), ncol = 8)
	
	if(subset == 'all'){
		dat.subset = dat.all
		}
	if(subset ==  'no.car'){
		dat.subset = dat.all[dat.all$habits != 1,]
		}

		
	z.variable = 'treatment'
	
	# This portion is really tricky because x.new and friends gets created as a
	# data.frame, which is now just an element of the dat.subset list. That is
	# weird enough, but then, later, we try to work with it and bad stuff happens.
	# I suspect that all this is fine if we just never turned the initial data into
	# a tibble. But maybe not! And, even if it does work, it is a bad idea. Trick
	# was to add "drop = TRUE", which ensures that the resulting object is a
	# vector.
	
	for(j in 1:length(repeats)){
		dat.subset$x.new <- (dat.subset[, x.names[j], drop = TRUE]- 1)/4  ##rescale x to 0-1
		dat.subset$y.new <- (dat.subset[, y.names[j], drop = TRUE]- 1)/4  ##rescale y to 0-1
		dat.subset$Y     <-  dat.subset$y.new - dat.subset$x.new
		
		dat.use <- dat.subset[is.na(dat.subset$Y) == F,]
		
		x.sd = sd(as.vector(dat.use$x.new),na.rm = T)
		x.mean = mean(dat.use$x.new,na.rm = T)
		y.mean = mean(dat.use$y.new,na.rm = T)
		y.treat = mean(dat.use$y.new[dat.use$treatment==1],na.rm = T)
	
		station.treatment.table <- table(dat.use$station, dat.use[ ,z.variable, drop = TRUE])
		no.control.stations = names(which(station.treatment.table[,1] == 0))
		no.treatment.stations = names(which(station.treatment.table[,2] == 0))
		dat.use = dat.use[!dat.use$station%in%c(no.control.stations,no.treatment.stations),]
				
		
		dat.use$station = factor(dat.use$station)
		dat.use$treated_unit = factor(dat.use$treated_unit)
		Xs = data.matrix(dat.use[,covariates])
		
		perms <- genperms(Z = dat.use[,z.variable], blockvar=dat.use$station, clustvar=dat.use$treated_unit)
		probs = genprobexact(Z = dat.use[,z.variable], blockvar=dat.use$station, clustvar=dat.use$treated_unit)

		ate = estate(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], X = Xs, prob = probs)
		Ys = genouts(Y = dat.use$Y, Z = dat.use[, z.variable, drop = TRUE], ate = 0)
		distout <- gendist(Ys,perms, prob=probs)
		disp =	dispdist(distout, ate = ate, display.plot = F)
		
		out.mat[j,1] = repeats[j]
		out.mat[j,2] = subset
		out.mat[j,3] = nrow(dat.use)
		out.mat[j,4] = ate
		out.mat[j,5] = disp$greater.p.value
		out.mat[j,6] = disp$lesser.p.value
		out.mat[j,7] = x.sd
		out.mat[j,8] = x.mean
		}
	final.mat = rbind(final.mat,out.mat)
	}

final.mat = as.data.frame(final.mat)
colnames(final.mat) = c('variable','subset','N','ate','greater.p.value','lesser.p.value','x.sd','x.mean')


final.mat.main = final.mat ##final.mat for output creation later

# Need more stuff before we can output the final table. Let's come back to this
# later. I am skipping subset_inference.r since it only (?) produces results for
# the supporting material.

```



```{r output_create, results="asis"}
# OMG! He calculates many (most?) of these numbers as factors! Check out
# sapply(final.mat.main, class). Then he has to convert to character and then to
# numeric to use them properly. Insanity! But, also, there should be a better
# way to clean this up.

final.mat.main$ate    <- as.numeric(as.character(final.mat.main$ate)) 
final.mat.main$N      <- as.numeric(as.character(final.mat.main$N)) 
final.mat.main$x.mean <- as.numeric(as.character(final.mat.main$x.mean)) 
final.mat.main$x.sd   <- as.numeric(as.character(final.mat.main$x.sd)) 
final.mat.main$greater.p.value <- as.numeric(as.character(final.mat.main$greater.p.value)) 

# Now that we have final.mat.main and final.mat.prime, we can make some nice
# output. The annoying part is that this data is very poorly organized, if our
# main purpose is to create Table 1. I really ought to go back and recalculate
# these data frames in a tidyier fashion. But, for now, we will just pick out
# the parts we want.

# This was annoyingly hard, which goes to show why it is nice to calculate
# important numbers in a sensible way in the first place.

ate_tib <- as_tibble(x = matrix(data = NA_real_, 
                                nrow = 4, 
                                ncol = 3,
                                dimnames = list(NULL,
                                  c("ATE (P)", 
                                    "CATE (P)",
                                     "T1 levels (SD)")))) %>%
  
  # Remember: tibbles can't have row names anymore. So, we need to make them a
  # variable.
  
  mutate(Question = c('Number of immigrants be increased?',
                      'Children of undocumented be allowed to stay?',
                      'English as official language?', 
                      'n')) %>% 
  mutate(`ATE (P)` = c(final.mat.main$ate[1:3], final.mat.main$N[2]),
         `CATE (P)` = c(final.mat.main$ate[4:6], final.mat.main$N[5]),
         `T1 levels (SD)` = c(final.mat.main$x.mean[1:3], final.mat.main$N[2])) %>% 
  select(Question, everything())

# Do the p-values

p_tib <- as_tibble(x = matrix(data = NA_real_, 
                                nrow = 3, 
                                ncol = 3,
                                dimnames = list(NULL,
                                  c("ATE (P)", 
                                    "CATE (P)",
                                     "T1 levels (SD)")))) %>% 
    mutate(Question = c('Number of immigrants be increased?',
                      'Children of undocumented be allowed to stay?',
                      'English as official language?')) %>% 
    mutate(`ATE (P)` = final.mat.main$greater.p.value[1:3],
         `CATE (P)` = final.mat.main$greater.p.value[4:6],
         `T1 levels (SD)` = final.mat.main$x.sd[1:3]) %>% 
  select(Question, everything())

# For now, I am not going to combine these into a single table.

# Discuss the confusion about exactly what those numbers mean. Does a high
# number mean the conservative answer?

ate_tib %>% gt() %>% as_raw_html() %>% as.character() %>% cat()
p_tib %>% gt() %>% as_raw_html() %>% as.character() %>% cat()

```

\newpage

## Table 2. Covariate balance across treatment conditions

```{r table_2, results="asis", tab.cap = NULL}
# I believe that this is the code which drives Table 2. I deleted the other
# tests. Note that income is present in the published table but at a different
# location than in the code. I could not get replicate the income numbers.
# Error?

out.balance.test <- xBalance(fmla = treatment ~ liberal + republican + obama.disapprove + 
                               ride.everyday + voted.2010 + romney.voter + Hispanics.x + 
                               age + residency.new + college + male +
                               hispanic.new +  white + income.new, data = dat.all, 
                             report = c("std.diffs","z.scores","adj.means"), 
                             strata = factor(dat.all$station))

# This creates an object of class xbal, which is obviously too annoying to work
# with since it is also a list with two items, and the first item is very
# strange. However, this incantation gets out the matrix of numbers we care
# about. Is there a better way?

x <- as_tibble(out.balance.test[1]$results[,,1][, 1:4]) %>% 
  mutate(condition = c("Liberal", "Republican", "Obama disapprove", 
                  "Ride MBTA every day", "Voted 2010", "Romney voter", "Hispanic threat", 
                   "Age", "Residency year", "College", "Male",  
                   "Hispanic", "White", "Income")) %>% 
  select(condition, everything())

colnames(x) <- c("Condition", "Control", "Treatment", "Standard difference", "Z Score")


# Enos just uses xtable(), for which xbal provides a method. But it sure does
# look ugly because xtable() has so few options. I will use gt.

# https://gt.rstudio.com/articles/creating-display-tables.html

gt_tbl <- x %>% 
  gt() %>% 
  tab_header(title = "Table 2. Covariate balance across treatment conditions") %>% 
  tab_options(footnote.glyph = c("*", "**")) %>%   # Really want the second symbol to be a dagger 
  tab_footnote(
    footnote = "Difference in standardized units.",
    locations = cells_column_labels(
      columns = vars(`Standard difference`))) %>% 
  tab_footnote(
    footnote = "Mean response values for the pretreatment variables accounting for stratification into train stations.",
    locations = cells_data(
      columns = vars(Condition),
      rows = 1)) 

gt_tbl %>% as_raw_html() %>% as.character() %>% cat()


```

I am able to replicate all the results for Table 2, except for those related to income. But, even there, my results are very close to those published.


## References
